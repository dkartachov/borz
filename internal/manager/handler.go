package manager

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/dkartachov/borz/internal/task"
	"github.com/go-chi/chi/v5"
	"github.com/google/uuid"
)

type TaskResponse struct {
	Task   task.Task
	Worker string
}

func (a *Api) getTasksHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(a.Manager.GetTasks())
}

func (a *Api) startTaskHandler(w http.ResponseWriter, r *http.Request) {
	var t task.Task

	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&t); err != nil {
		log.Printf("[%v] error decoding json: %v", a.Manager.name, err)
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	t.Id = uuid.New() // CHECKME this should probably be generated by the database. Should tasks be stored persistently?
	t.State = task.Pending
	a.Manager.AddTask(t)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(t)
}

func (a *Api) stopTaskHandler(w http.ResponseWriter, r *http.Request) {
	taskId := chi.URLParam(r, "taskId")
	if taskId == "" {
		http.Error(w, "must specify taskId", http.StatusBadRequest)
		return
	}

	id, err := uuid.Parse(taskId)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	t, exists := a.Manager.tasks[id]
	if !exists {
		http.Error(w, fmt.Sprintf("task %v not found", id), http.StatusNotFound)
		return
	} else if t.State != task.Running {
		http.Error(w, fmt.Sprintf("cannot stop task in %v state", t.State), http.StatusBadRequest)
		return
	}

	a.Manager.AddTask(task.Task{Id: id, State: task.Stopping})
	w.WriteHeader(http.StatusNoContent)
}

func (a *Api) shutDownHandler(w http.ResponseWriter, r *http.Request) {
	a.online = false
	close(a.Manager.signal.ShutdownTaskScheduler)
	workers := a.Manager.Workers
	// TODO Start some kind of polling goroutine that hits an endpoint to check if all workers have been
	// shut down. Once all workers have been shut down, initiate manager shutdown.
	for _, w := range workers {
		resp, err := http.Post(fmt.Sprintf("%s/shutdown", w), "application/json", nil)
		if err != nil {
			log.Printf("[%v] error connecting to worker %s", a.Manager.name, w)
			continue
		}

		if resp.StatusCode != http.StatusOK {
			log.Printf("[%v] error shutting down worker %s", a.Manager.name, w)
		}

		resp.Body.Close()
	}

	// TODO add context timeout to prevent infinite loop
	go func() {
		log.Printf("[%s] polling for workers shutdown", a.Manager.name)
		shutdown := 0
		for shutdown < len(workers) {
			for _, w := range workers {
				resp, err := http.Get(fmt.Sprintf("%s/alive", w))
				if err != nil {
					shutdown += 1
					continue
				}

				resp.Body.Close()
			}

			time.Sleep(time.Second * 1)
		}
		close(a.Manager.signal.ShutdownAPI)
	}()

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("graceful shutdown initiated"))
}
